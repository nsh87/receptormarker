#' @title Cluster using kmeans  or hclust over multiple k and find optimal k
#' @description This calls the function \code{\link[stats]{kmeans}} or
#' \code{\link[stats]{hclust}} to perform clustering, but initializes
#' multiple times. It chooses the best clustering for each number of clusters
#' (there are multiple runs for each k) based on within sum of squares.
#' The best overall k (i.e. best number of clusters to use for the data set)
#' is then chosen by running the data set through a number of different cluster
#' estimation algorithms. Majority rule of all the algorithms determines the
#' optimal k. For example, if 12 algorithms suggest that k = 9 and 7
#' algorithms suggest that k = 6 then the optimal k will be 9.
#' @details The \code{\link{multiClust-class}} object returned is primarily
#' intended for use with the plotting functions in the \emph{receptormarker}
#' package (the See Also section contains a complete list). However, its
#' elements can also be accessed directly for other uses. See the
#' \code{\link{multiClust-class}} documentation for details.
#'
#' When choosing the values to pass in for each parameter, the defaults will
#' likely perform well to start. However, a large \code{krange} will generate
#' more work for the function, so if certain values are definitely not going
#' to be used and are not best, then consider not including them in
#' \code{krange} for performance benefits. Reducing the number of \code{runs}
#' will have performance benefits as well, though they may not be as
#' pronounced. More runs increases the likelihood of finding the best
#' clustering for a given number of clusters, k, with a given algorithm.
#' \code{iter.max} controls how many times the algorithm recalculates to try
#' to converge on an ideal clustering. Without significant adjustments up or
#' down in number, few changes in performance should be observed here.  
#' 
#' \strong{TIP:} When using the clustering portion of the
#' \emph{receptormarker} package, a reasonable workflow might be:  
#' \enumerate{
#'   \item Create a \code{\link{multiClust-class}} object using this function.
#'   \item Send that object to the functions \code{\link{wss_plot}},
#'     \code{\link{gap_plot}}, and \code{\link{avg_sil_plot}} with
#'     \code{optimal = TRUE} to see which number of clusters is recommended
#'     and compare it to these respective plots.
#'   \item Choose the number of clusters to be used.
#'   \item View the \code{\link{sil_plot}} using your chosen number of
#'     clusters to confirm the choice.
#'   \item View the \code{\link{pca_plot}} using your chosen number of clusters
#'     to see the shape of the data using its first two principal components.
#'   \item View the \code{\link{clust_boxplot}} using your chosen number of
#'     clusters to see the cluster membership of each feature (likely
#'     phenotypic markers). This should yield useful conclusions.
#' } 
#' @param d A numeric matrix of data, or an object that can be coerced to
#' such a matrix (such as a numeric vector or a data frame with all numeric
#' columns).
#' @param krange An integer vector describing the range of k (numbers of
#' clusters) which are to be compared. Note: \code{krange} should not
#' include 1 since silhouette scores and clusters are not defined at this value.
#' @param iter.max An integer representing the maximum number of iterations
#' used to find cluster centers when running kmeans. Only used when the
#' \code{algorithm} parameter is set to "kmeans".
#' @param runs An integer representing the number of starts of the kmeans
#' algorithm for each k. Only used when the \code{method} parameter is set to
#' "kmeans".
#' @param algorithm Either "kmeans" or "hclust". If "kmeans", then the
#' \code{\link[stats]{kmeans}} function is used for clustering. If "hclust",
#' then the \code{\link[stats]{hclust}} function is used for clustering.
#' @param method Either "silhouette" or "exhaustive". If "silhouette", then the
#' average silhouette score will be used to estimate the optimal k.
#' If "exhaustive", then \code{\link{NbClust}} will be used to
#' estimate optimal k, although this takes significantly longer and is more
#' error prone since the data is run through upwards of 20 algorithms for
#' clustering; consider this method to be in beta.
#' @param index The index to be calculated for determining the optimal k, passed
#' to \code{\link{NbClust}} (see its documentation for details on this
#' parameter). Only used when \code{method} is set to "exhaustive".
#' @param ... Further arguments to be passed to \code{\link[stats]{kmeans}} or
#' \code{\link[stats]{hclust}}.
#' @return An object of class \code{\link{multiClust-class}}. This object can
#' be used to create several plots (refer to the See Also section) that aid
#' in determining the optimal k for the data set. It also contains statistics
#' about each clustering in \code{krange}.
#' @export
#' @seealso \code{\link{wss_plot}}, \code{\link{gap_plot}}, 
#' \code{\link{pca_plot}}, \code{\link{sil_plot}}, \code{\link{avg_sil_plot}},
#' \code{\link{clust_boxplot}}, \code{\link{multiClust-class}}
#' @examples
#' # Common data set
#' library(datasets)
#' iris_clust <- multi_clust(iris[, 1:4])
#' # Domain data set
#' data(fluidigm)
#' fluidigm_clust <- multi_clust(fluidigm[1:40, ])
multi_clust <- function(d, krange = 2:15, iter.max = 500, runs = 10,
                        algorithm = "kmeans", method = "silhouette",
                        index = "alllong", ...) {
  validate_not_null(list(d = d, krange = krange, iter.max = iter.max, 
                         runs = runs, method = method, index = index))
  validate_k_range(krange)
  validate_pos_num(list(iter.max = iter.max, runs = runs))
  validate_num_data(d)
  validate_multi_clust_method(method)
  validate_multi_clust_algorithm(algorithm)
  krange <- sort(krange)
  if (is_boolean(d)) {
    distance <- "binary"
  } else {
    distance <- "euclidean"
  }
  d <- d[complete.cases(d), ]
  d_dist <- dist(d, method = distance)
  cl <- list(clust_model = NULL, sil_avg = NULL, num_clust = NULL, sil = NULL,
             clust_gap = NULL, wss = NULL, k_best = NULL)
  # Perform clustering for every k in krange
  if (algorithm == "kmeans") {
    for (k in krange) {
      tryCatch({
        cl_opt <- stats::kmeans(d, k, iter.max = iter.max, nstart = runs, ...)
      },
      error = function(e) {
        if (grepl("cluster centers than distinct", e)) {
          stop("The same data points repeat such that only less than ", k,
               "clusters can be calculated. Please adjust the krange ",
               "accordingly and rerun multi_clust.", call. = FALSE)
        } else {
          stop(e, call. = FALSE)
        }
      }
      )
      if (distance == "euclidean") {
        min_wss <- cl_opt[["tot.withinss"]]
      } else {
        min_wss <- totwss(d_dist, cl_opt[["cluster"]])
      }
      sil <- cluster::silhouette(cl_opt[["cluster"]], d_dist)
      sil_sum <- summary(sil)
      sil_avg <- sil_sum[["avg.width"]]
      
      cl[["clust_model"]][[k]] <- cl_opt
      cl[["sil_avg"]][[k]] <- sil_avg
      cl[["num_clust"]][[k]] <- k
      cl[["sil"]][[k]] <- sil
      cl[["wss"]][[k]] <- min_wss
    }
  } else if (algorithm == "hclust") {
    cl_opt <- stats::hclust(d_dist, method = "average")
    clustering <- stats::cutree(cl_opt, k = krange)
    for (i in 1:length(krange)) {
      k <- krange[i]
      clusters <- clustering[, i]
      sil <- cluster::silhouette(clusters, d_dist)
      sil_sum <- summary(sil)
      sil_avg <- sil_sum[["avg.width"]]
      cl_opt[["cluster"]] <- clusters
      
      cl[["clust_model"]][[k]] <- cl_opt
      cl[["sil_avg"]][[k]] <- sil_avg
      cl[["num_clust"]][[k]] <- k
      cl[["sil"]][[k]] <- sil
      cl[["wss"]][[k]] <- totwss(d_dist, clusters)
    }
  } else {
    stop("You have chosen an invalid algorithm. Please choose one of kmeans ",
         "or hclust.", call. = FALSE)
  }
  cl[["clust_gap"]] <- cluster::clusGap(d, kmeans,
                                        K.max = length(cl[["clust_model"]]),
                                        B = 15, verbose = FALSE)
  # Estimate K using the average silhouette score if method == 'kmeans'
  if (method == "silhouette") {
    cl[["k_best"]] <- which.max(cl[["sil_avg"]])
  } else if (method == "exhaustive") {
    # Estimate K using NbClust if method == 'exhaustive'
    tryCatch({
      nb_best <- suppressWarnings(suppressMessages(
        NbClust(d,
                min.nc = krange[1],
                index = index,
                max.nc = krange[length(krange)],
                distance = distance,
                method = "average")))
    },
    error = function(e) {
      if (grepl("computationally singular", e)) {
        stop("There are not enough rows of data to evaluate for clustering.",
             call. = FALSE)
      } else {
        stop(e, call. = FALSE)
      }
    }
    )
    best <- aggregate(nb_best[["Best.nc"]][1, ], 
                      by = list(nb_best[["Best.nc"]][1, ]), length)
    idx <- which.max(best[[2]])
    cl[["k_best"]] <- best[idx, 1]
  }
  new("multiClust", clust_model=cl[["clust_model"]], sil_avg=cl[["sil_avg"]],
      num_clust=cl[["num_clust"]], sil=cl[["sil"]], clust_gap=cl[["clust_gap"]],
      wss=cl[["wss"]], k_best=cl[["k_best"]])
}
