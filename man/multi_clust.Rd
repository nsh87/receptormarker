% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_clustering.R
\name{multi_clust}
\alias{multi_clust}
\title{Cluster using kmeans over multiple k and find optimal k}
\usage{
multi_clust(d, krange = 2:15, iter.max = 300, runs = 10,
  method = "kmeans", ...)
}
\arguments{
\item{d}{A numeric matrix of data, or an object that can be coerced to
such a matrix (such as a numeric vector or a data frame with all numeric
columns).}

\item{krange}{An integer vector describing the range of k (numbers of
clusters) which are to be compared. Note: \code{krange} should not
include 1 since silhouette scores are not defined there.}

\item{iter.max}{An integer representing the maximum number of iterations to
be find cluster centers when running kmeans.}

\item{runs}{An integer representing the number of starts of the k-means
algorithm for each k.}

\item{method}{Either "kmeans", "hclust", or "both". Currently, it
does nothing, but functionality will be added in the future.}

\item{...}{Further arguments to be passed to \code{\link[stats]{kmeans}}.}
}
\value{
An object of class \code{\link{multiClust-class}}. This object can
be used to create several plots (refer to the See Also section) that aid
in determining the optimal k for the data set. It also contains statistics
about each clustering in \code{krange}.
}
\description{
This calls the function \code{\link[stats]{kmeans}} to perform
kmeans clustering, but initializes multiple times. It chooses the best
clustering for each number of clusters (there are multiple runs for each
k) based on within sum of squares. The best overall k (i.e. best number of
clusters to use for the data set) is then chosen by running the data set
through a number of different cluster estimation algorithms. Majority rule
of all the algorithms determines the optimal k. For example, if 12 algorithms
suggest that k=9 and 7 algorithms suggest that k=6 then the optimal k will
be 9.
}
\details{
The \code{\link{multiClust-class}} object returned is primarily
intended for use with  #' the plotting functions in the \emph{receptormarker}
package (the See Also section contains a complete list). However, its
elements can also be accessed directly for other uses. See the
\code{\link{multiClust-class}} documentation for details.

When choosing the values to pass in for each parameter, the defaults will
likely perform well to start. However, a large \code{krange} will generate
more work for the function, so if certain values are definitely not going
to be used and are not best, then consider not including them in
\code{krange} for performance benefits. Reducing the number of \code{runs}
will have performance benefits as well, though they may not be as
pronounced. More runs increases the likelihood of finding the best
clustering for a given number of clusters, k, with a given algorithm.
\code{iter.max} controls how many times the algorithm recalculates to try
to converge on an ideal clustering. Without significant adjustments up or
down in number, few changes in performance should be observed here.  

\strong{TIP:} When using the clustering portion of the
\emph{receptormarker} package, a reasonable workflow might be:  
\enumerate{
  \item Create a \code{\link{multiClust-class}} object using this function.
  \item Send that object to the functions \code{\link{wss_plot}},
    \code{\link{gap_plot}}, and \code{\link{avg_sil_plot}} with
    \code{optimal = TRUE} to see which number of clusters is recommended
    and compare it to these respective plots.
  \item Choose the number of clusters to be used.
  \item View the \code{\link{sil_plot}} using your chosen number of
    clusters to confirm the choice.
  \item View the \code{\link{pca_plot}} using your chosen number of clusters
    to see the shape of the data using its first two principal components.
  \item View the \code{\link{clust_boxplot}} using your chosen number of
    clusters to see the cluster membership of each feature (likely
    phenotypic markers). This should yield useful conclusions.
}
}
\examples{
# Common data set
library(datasets)
iris_clust <- multi_clust(iris[, 1:4])
# Domain data set
data(fluidigm)
fluidigm_clust <- multi_clust(fluidigm[1:40, ])
}
\seealso{
\code{\link{wss_plot}}, \code{\link{gap_plot}}, 
\code{\link{pca_plot}}, \code{\link{sil_plot}}, \code{\link{avg_sil_plot}},
\code{\link{clust_boxplot}}, \code{\link{multiClust-class}}
}

